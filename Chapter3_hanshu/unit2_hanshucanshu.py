
###################### 3.2 函数的参数 #############################

#3.2.1 形参和实参
'''
1、在定义函数时候，指定的参数称为形式参数，简单是行参
2、在调用函数的时候，给函数传递的参数称为实参
3、在定义函数时候，形参是没有分配空间的，相当一个占位符
4、在调用函数的时候，会在栈区给函数分配存储空间，然后给参数、局部变量分配存储空间，传递的是实际的参数
5、当函数结束的时候，函数所占领的空间会被释放，变函数的形参、局部变量也会被释放
'''
import copy

#3.2.1 函数的参数传递

'''
1、在python中，类型属于对象，变量是没有类型的
2、在python中，变量和数据是分开存储的，数据保存在内存中的一个位置，变量保存着数据在内存的地址，变量中记录数据的地址，就叫做引用
3、使用id()可以查看变量中保存数据所在的地址
4、一切都是对象，严格意思来说我们说值传递还是引用传递，应该说传不可变量对象和传可变对象

def changeInt(a):
    print('函数体中未改变前a的内存地址',id(a))
    a = 2
    print('函数体中  改变后a的内存地址',id(a))

b = 10

changeInt(b)

print("函数外b的内存地址",id(b))
'''

#3.2.2 函数可使用的参数形式
'''
1、调用函数是，必须将函数调用中的每一个参数都关联到函数定义的一个形参
最简单就是基于位置把伟哥相应位置的实参和形参相连，调用时必须和声明一样
def func(a,b,c):
    print(a,c,b)

func(1,2,3)

2、函数调用使用关键字参数来确定每个变量的传入的参数值，使用关键字参数允许函数调用是参数的顺序不一样

def printInfo(name,age):
    print(name,age)

printInfo(age=18,name='zhanlin')

3、定义函数的时候，可以给每个参数默认值，在调用函数的时候，给形参提供一个实参则使用指定值，否则使用默认值
def printInfo2(name,age=20):
    print(name)
    print(age)

printInfo2('zhanlin')

printInfo2('zhanlin',30)

4、不定长传参；如果后面还有参数，必须通过关键字传惨
def printInfo3(num1,*vartuple,num):
    print(num1)
    print(vartuple)
    print(num)

printInfo3(1,10,20,30,num=40)
注意：
(1)、加了星号 * 的参数会以元组的形式导入，存放所有未命名的参数
(2)、如果形参中出现了不定长参数，那么在函数调用的时候，先通过位置进行必须参数的匹配，然后不定长后面的参数必须通过关键字匹配
(3)、加了两个 ** 的参数会以字典的形式导入，后面不能有其他参数

def printInfo4(num,**vardict):
    print(num)
    print(vardict)

printInfo4(10,a=20,c=30)

5、解包传参数：如果函数的形参是定长参数，可以通过* 和 ** 对列表、元组、字段等解包传参,但是个数需要一样

def printInfo5(a,b):
    print(a+b)

tuple3 = (1,2)

printInfo5(*tuple3)

dict1 = {"a": 1, "b": 2} #字典中key的名称和参数名必须一致

printInfo5(**dict1)


5、强制使用位置参数或者关键字参数

/ 前面的参数必须使用位置参数，* 后面必须使用关键字参数


6、防止函数修改列表,可以使用copy.deepcopy().
def multiply(var1):
    var1[3].append(400)
    print('函数处理之后:',var1)

list1 = [1, 2, 3, [100, 200, 300]]



multiply(copy.deepcopy(list1))

print(list1)


7、编写函数文档之后，可以通过help(函数名称)获取解释

def printInfo():

    \'\'\'
    这个是一个例子解释
    :return:
    \'\'\'
    print('nihao')

help(printInfo)

'''


#3.2.3 变量作用域

'''
1、定义在函数内部的变量有一个局部作用域，定义在函数外的拥有全局作用域
2、函数内部使用global声明全局变量之后，可以修改全局变量
def globalA():

    global vars
    vars = 100
    print(vars)

vars = 10

print(vars)
globalA()
print(vars)

3、不可变类型的全局变量其指向的数据不能改变，所以不使用global无法修改全局变量
4、可变类型的全局变量其指向的数据可以修改，所以不用global也能修改全局变量

5、nonlocal 也可以作内部作用域修改外部作用域的变量场景，不过此时外部作用域不是全局作用域，而是嵌套作用域
'''






